import { Injectable } from '@angular/core';

import * as moment from 'moment';
import * as _ from 'lodash';

import { MonthYear, DateService, DayType } from 'app/core/core-services/date';
import { ArrayMapper } from 'app/infrastructure/array-utilities';

import { TimeReportEntry } from 'app/shared/features/time-report-entry-search';
import { Employment } from 'app/shared/features/employee-administration';

import { EmployeeWorkMonth, EmployeeWorkDisplayType } from '../models';

@Injectable()
export class EmployeeWorkMonthCalculationService {
  private employments: Employment[];
  private readonly defaultWorkDay = 8.5;
  private readonly defaultWorkDay = 8.5;

  public set abc(str: string) {

  }

  public get handledElementName(): string {
    return 'Public Property';
  }

  public set handledElementName(str: string) {
  }

  public get abc(): string {
    return 'Public Property';
  }

  constructor(
    private dateService: DateService) {
  }

  public createOverallEntry(workMonths: EmployeeWorkMonth[]): EmployeeWorkMonth {
    const result = new EmployeeWorkMonth();
    result.headingDescription = 'Overall';
    result.timeActual = workMonths.map(f => f.timeActual).reduce((pv, cv) => pv + cv, 0);
    result.timeHolidays = workMonths.map(f => f.timeHolidays).reduce((pv, cv) => pv + cv, 0);
    result.timeSchool = workMonths.map(f => f.timeSchool).reduce((pv, cv) => pv + cv, 0);
    result.timeSickOrAccident = workMonths.map(f => f.timeSickOrAccident).reduce((pv, cv) => pv + cv, 0);
    result.workPercent = workMonths.map(f => f.workPercent).reduce((pv, cv) => pv + cv, 0) / workMonths.length;
    result.timeExpected = workMonths.map(f => f.timeExpected).reduce((pv, cv) => pv + cv, 0);
    return result;
  }

  public calculateMonthsForYear(timeReportEntries: TimeReportEntry[],
    displayType: EmployeeWorkDisplayType,
    year: number,
    employments: Employment[]): EmployeeWorkMonth[] {
    this.employments = employments;
    let result = new Array<EmployeeWorkMonth>();

    if (timeReportEntries.length > 0) {
      timeReportEntries = this.filterByYear(timeReportEntries, year);
      const entriesGrpByMonth = this.groupEntriesByMonth(timeReportEntries);
      result = this.createAllMonthlyEntries(entriesGrpByMonth, displayType, year);

      result = this.sortEntries(result);
    }

    return result;
  }

  private sortEntries(workMonths: EmployeeWorkMonth[]): EmployeeWorkMonth[] {
    const result = workMonths.sort((a, b) => {
      return a.sequence - b.sequence;
    });

    return result;
  }

  private createAllMonthlyEntries(
    timeReportEntriesDict: _.Dictionary<TimeReportEntry[]>,
    displayType: EmployeeWorkDisplayType,
    year: number): EmployeeWorkMonth[] {
    const result = new Array<EmployeeWorkMonth>();

    _.forEach(timeReportEntriesDict, (data, month) => {
      const monthNumber = Number(month);
      const monthYear = new MonthYear(monthNumber, year);
      const workMonth = this.createMonthlyEntry(data, displayType, monthYear);
      result.push(workMonth);
    });

    return result;
  }

  private groupEntriesByMonth(timeReportEntries: TimeReportEntry[]): _.Dictionary<TimeReportEntry[]> {
    const result = _.groupBy(timeReportEntries, f => {
      const currentMonth = moment(f.bookingDate).month() + 1;
      return currentMonth;
    });

    return result;
  }

  private filterByYear(timeReportEntries: TimeReportEntry[], year: number): TimeReportEntry[] {
    const result = timeReportEntries.filter(f => {
      return moment(f.bookingDate).year() === year;
    });

    return result;
  }

  private createMonthlyEntry(timeReportEntries: TimeReportEntry[],
    displayType: EmployeeWorkDisplayType,
    monthYear: MonthYear): EmployeeWorkMonth {
    const result = this.createWorkMonthTime(timeReportEntries, displayType);
    result.sequence = monthYear.month;
    result.headingDescription = monthYear.monthDescription;

    const workPercent = this.getEmploymentWorkPercent(monthYear);
    result.workPercent = workPercent;
    result.timeExpected = this.getExpectedWorkTime(monthYear, displayType, workPercent);

    return result;
  }

  private getExpectedWorkTime(monthYear: MonthYear, displayType: EmployeeWorkDisplayType, workPercent: number): number {
    let workTimeInMonth = this.dateService.getDaysInMonth(monthYear, DayType.WorkDay) * this.defaultWorkDay;
    workTimeInMonth = workTimeInMonth / 100 * workPercent;

    const result = this.calculateTimeByDisplayType(workTimeInMonth, displayType);
    return result;
  }

  private getEmploymentWorkPercent(monthYear: MonthYear): number {
    const currentMonthMoment = monthYear.toMoment();

    const employmentInRange = this.employments.find(f => {
      const empMomentFrom = moment(f.from);
      const empMomentTo = moment(f.to);

      const currentMonthIsLargerThanFrom = empMomentFrom <= currentMonthMoment;
      let currentMonthIsSmallerThanTo = true;
      if (empMomentTo.isValid()) {
        currentMonthIsSmallerThanTo = empMomentTo > currentMonthMoment;
      }

      return currentMonthIsLargerThanFrom && currentMonthIsSmallerThanTo;
    });

    if (employmentInRange) {
      return employmentInRange.workPercent;
    }

    return 100;
  }

  private createWorkMonthTime(timeReportEntries: TimeReportEntry[], displayType: EmployeeWorkDisplayType): EmployeeWorkMonth {
    const result = new EmployeeWorkMonth();
    result.timeActual = this.calculateEfforts(timeReportEntries, displayType);
    result.timeHolidays = this.calculateEfforts(timeReportEntries.filter(f => f.isHoliday), displayType);
    result.timeSchool = this.calculateEfforts(timeReportEntries.filter(f => f.isSchool), displayType);
    result.timeSickOrAccident = this.calculateEfforts(timeReportEntries.filter(f => f.isSickOrAccident), displayType);
    return result;
  }

  private calculateEfforts(data: TimeReportEntry[], displayType: EmployeeWorkDisplayType): number {
    let result = 0;

    if (data.length > 0) {
      result = data.map(f => f.effortInHours).reduce((a, b) => {
        return a + b;
      });

      result = this.calculateTimeByDisplayType(result, displayType);
    }

    return result;
  }

  private calculateTimeByDisplayType(hours: number, displayType: EmployeeWorkDisplayType): number {
    let result = hours;

    if (displayType === EmployeeWorkDisplayType.Days) {
      result = result / this.defaultWorkDay;
    }

    result = _.round(result, 2);

    return result;
  }
}
